<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>离网矿区光风储柴仿真 · V2.4_plus（两图简洁版）</title>
<style>
  :root{--fg:#111;--muted:#666;--box:#d1d5db}
  *{box-sizing:border-box}
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Noto Sans",sans-serif;color:var(--fg);margin:14px}
  h1{font-size:18px;margin:0 0 8px}
  .row{display:flex;flex-wrap:wrap;gap:12px;margin:10px 0}
  .card{border:1px solid var(--box);border-radius:10px;padding:12px;background:#fff;flex:1 1 320px}
  label{display:block;font-size:12px;margin:6px 0 3px}
  input[type=number],select{width:100%;padding:7px 9px;border:1px solid #cbd5e1;border-radius:8px}
  .btn{padding:8px 12px;border:1px solid #111;border-radius:8px;background:#fff;cursor:pointer}
  .btn.secondary{border-color:#666;color:#333}
  .kv{font-family:ui-monospace,Menlo,Consolas,monospace}
  canvas{width:100%;height:280px;background:#fff;border:1px solid #eee;border-radius:10px}
  .kpi{display:flex;gap:10px;flex-wrap:wrap}
  .kpi .box{border:1px solid var(--box);border-radius:10px;padding:8px 10px;min-width:150px}
  .kpi .box b{display:block;font-size:12px;color:#374151}
  .kpi .box span{display:block;font-size:18px;margin-top:2px}
  #log{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;max-height:150px;overflow:auto;border:1px solid #eee;border-radius:8px;padding:8px;background:#fafafa}
</style>
</head>
<body>
<h1>Off-Grid Mining Microgrid — 35 kV · <span class="kv">V2.4_plus</span></h1>
<div class="row">
  <div class="card" style="flex:1 1 320px">
    <b>全局</b>
    <label>仿真时长（小时）</label><input id="simHours" type="number" value="24" step="1">
    <label>步长 dt（秒）</label><input id="dt" type="number" value="0.5" step="0.1">
    <label>名义频率 f0（Hz）</label><input id="f0" type="number" value="60" step="1">
    <label>系统阻尼 D（pu）</label><input id="Dsys" type="number" value="2.2" step="0.1">
    <label>负荷随频 α（%/Hz）</label><input id="alphaLoad" type="number" value="2.0" step="0.1">
    <div style="margin-top:8px">
      <button class="btn" id="startBtn">▶ 开始</button>
      <button class="btn secondary" id="pauseBtn">⏸ 暂停</button>
      <button class="btn secondary" id="resetBtn">↺ 重置</button>
    </div>
  </div>

  <div class="card" style="flex:1 1 320px">
    <b>负载 / 可再生</b>
    <label>负载基线（MW）</label><input id="Pload" type="number" value="12" step="0.5">
    <label>负载波动幅度（MW）</label><input id="loadVar" type="number" value="1.2" step="0.2">
    <hr>
    <label>PV 装机上限（MW）</label><input id="PpvMax" type="number" value="30" step="1">
    <label>PV 日形（1–3, 越大越尖）</label><input id="pvShape" type="number" value="1.5" step="0.1">
    <label>云影强度（0–1）</label><input id="pvCloud" type="number" value="0.35" step="0.05" min="0" max="1">
    <label>污染/积尘（0.7–1）</label><input id="pvSoil" type="number" value="0.9" step="0.01" min="0.7" max="1">
    <hr>
    <label>风电装机（MW）</label><input id="PwindMax" type="number" value="6" step="1">
    <label>平均风速（m/s）</label><input id="windMean" type="number" value="8" step="0.5">
    <label>风速波动强度（0–1）</label><input id="windVar" type="number" value="0.4" step="0.05" min="0" max="1">
  </div>

  <div class="card" style="flex:1 1 320px">
    <b>柴油（VF）</b>
    <label>3.3MW 初始在网台数（0–6）</label><input id="dg33n" type="number" value="3" step="1" min="0" max="6">
    <label>1.25MW 初始在网台数（0–2）</label><input id="dg12n" type="number" value="0" step="1" min="0" max="2">
    <label>有功下垂 R<sub>P</sub>（%）</label><input id="Rdg" type="number" value="4" step="0.5">
    <label>单台最低负载（pu）</label><input id="dgMinPu" type="number" value="0.35" step="0.05">
    <label>上调爬坡（MW/s）</label><input id="rampUp" type="number" value="0.2" step="0.05">
    <label>下调爬坡（MW/s）</label><input id="rampDn" type="number" value="1.0" step="0.1">
    <label>启停延时（s）</label><input id="dgDelay" type="number" value="600" step="30">
    <label>启停迟滞上/下（MW）</label><input id="dgHyst" type="number" value="1.5" step="0.1">
    <label>允许全部停机</label>
    <select id="allowDieselOff"><option value="false" selected>否（至少1台在线）</option><option value="true">是</option></select>
  </div>

  <div class="card" style="flex:1 1 320px">
    <b>BESS（VSG）</b>
    <label>P<sub>max</sub>（MW）</label><input id="PbMax" type="number" value="8" step="0.5">
    <label>E<sub>max</sub>（MWh）</label><input id="EbMax" type="number" value="20" step="1">
    <label>初始 SOC（%）</label><input id="soc0" type="number" value="60" step="1">
    <label>下垂 R<sub>P</sub>（%）</label><input id="Rvsg" type="number" value="3" step="0.5">
    <label>虚拟惯量 H（s）</label><input id="Hvsg" type="number" value="6.0" step="0.1">
    <label>SOC 目标/窗口（%，如 55 / 10）</label>
    <div class="row" style="gap:8px"><input id="socTarget" type="number" value="55"><input id="socBand" type="number" value="10"></div>
    <label>应急：|Δf| 阈值（Hz）/ 过载倍数 / 时间窗（s）</label>
    <div class="row" style="gap:8px"><input id="femg" type="number" value="0.2" step="0.05"><input id="overMul" type="number" value="1.4" step="0.1"><input id="overSec" type="number" value="8" step="1"></div>
  </div>

  <div class="card" style="flex:1 1 320px">
    <b>保护/限功</b>
    <label>RoCoF 限值（Hz/s）</label><input id="rocMax" type="number" value="0.9" step="0.1">
    <label>Hz–W 限功（两段）：k1(60.2–60.5)/k2(&gt;60.5)</label>
    <div class="row" style="gap:8px"><input id="kof1" type="number" value="0.5" step="0.1"><input id="kof2" type="number" value="2.0" step="0.1"></div>
    <label>OF1 阈值（Hz）/时限（s）</label>
    <div class="row" style="gap:8px"><input id="of1f" type="number" value="60.5" step="0.1"><input id="of1t" type="number" value="10" step="1"></div>
    <label>OF2 阈值（Hz）/时限（s）</label>
    <div class="row" style="gap:8px"><input id="of2f" type="number" value="61.0" step="0.1"><input id="of2t" type="number" value="0.2" step="0.1"></div>
    <label>跳闸后重合闸（s）</label><input id="reclose" type="number" value="30" step="1">
  </div>
</div>

<div class="row">
  <div class="card" style="flex:2 1 560px">
    <b>功率（MW） · 24h</b>
    <canvas id="pPlot"></canvas>
  </div>
  <div class="card" style="flex:1 1 340px">
    <b>频率（Hz）/ SOC（%） · 24h</b>
    <canvas id="fPlot"></canvas>
    <div id="live" class="kv" style="margin-top:6px"></div>
  </div>
</div>

<div class="card">
  <b>指标 & 日志</b>
  <div class="kpi" id="kpiRow">
    <div class="box"><b>燃油消耗</b><span id="kpiFuel">0 L</span></div>
    <div class="box"><b>可再生占比</b><span id="kpiRE">0%</span></div>
    <div class="box"><b>弃电（PV+风）</b><span id="kpiCurt">0 MWh</span></div>
    <div class="box"><b>N−1 校核</b><span id="kpiN1">OK</span></div>
    <div class="box"><b>最近窗口</b><span id="kpiWin">—</span></div>
  </div>
  <div id="log"></div>
</div>

<script>
(function(){
  // —— 可见参数与上下文 ——
  const COLORS={ pv:'#E69F00', wind:'#D55E00', load:'#000000', diesel:'#0072B2', bess:'#009E73', freq:'#6A3D9A', soc:'#009E73' };
  const el=id=>document.getElementById(id);
  const els={
    simHours:el('simHours'), dt:el('dt'), f0:el('f0'), Dsys:el('Dsys'), alphaLoad:el('alphaLoad'),
    Pload:el('Pload'), loadVar:el('loadVar'),
    PpvMax:el('PpvMax'), pvShape:el('pvShape'), pvCloud:el('pvCloud'), pvSoil:el('pvSoil'),
    PwindMax:el('PwindMax'), windMean:el('windMean'), windVar:el('windVar'),
    dg33n:el('dg33n'), dg12n:el('dg12n'), Rdg:el('Rdg'), dgMinPu:el('dgMinPu'),
    rampUp:el('rampUp'), rampDn:el('rampDn'), dgDelay:el('dgDelay'), dgHyst:el('dgHyst'), allowDieselOff:el('allowDieselOff'),
    PbMax:el('PbMax'), EbMax:el('EbMax'), soc0:el('soc0'), Rvsg:el('Rvsg'), Hvsg:el('Hvsg'), socTarget:el('socTarget'), socBand:el('socBand'),
    femg:el('femg'), overMul:el('overMul'), overSec:el('overSec'),
    rocMax:el('rocMax'), kof1:el('kof1'), kof2:el('kof2'), of1f:el('of1f'), of1t:el('of1t'), of2f:el('of2f'), of2t:el('of2t'), reclose:el('reclose'),
    startBtn:el('startBtn'), pauseBtn:el('pauseBtn'), resetBtn:el('resetBtn'),
    pPlot:el('pPlot'), fPlot:el('fPlot'), live:el('live'),
    kpiFuel:el('kpiFuel'), kpiRE:el('kpiRE'), kpiCurt:el('kpiCurt'), kpiN1:el('kpiN1'), kpiWin:el('kpiWin'),
    log:el('log')
  };
  const pctx=els.pPlot.getContext('2d'); const fctx=els.fPlot.getContext('2d');
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const fmt=(v,u)=>v.toLocaleString(undefined,{maximumFractionDigits:(Math.abs(v)<10?2:1)})+(u?(" "+u):"");
  function log(s){ els.log.textContent += s+"\n"; els.log.scrollTop=els.log.scrollHeight; }

  let running=false, series=[], st={};

  // —— 初始化状态 ——
  function initState(){
    const f0=+els.f0.value;
    st={
      t:0, f0, f:f0,
      T:+els.simHours.value*3600,
      Sbase:Math.max(12,+els.Pload.value),
      // 负载
      load:{ base:+els.Pload.value, var:+els.loadVar.value },
      // PV/Wind
      pv:{ Pmax:+els.PpvMax.value, shape:+els.pvShape.value, cloud:+els.pvCloud.value, soil:+els.pvSoil.value,
           curtWh:0, ofTrip:0, ofDelay:0 },
      wind:{ Pmax:+els.PwindMax.value, vmean:+els.windMean.value, vvar:+els.windVar.value,
             curtWh:0, ofTrip:0, ofDelay:0, stopReset:0 },
      // 柴油群
      dg:{ fleet:[], Rdg:(+els.Rdg.value)/100, minPu:+els.dgMinPu.value, delay:+els.dgDelay.value,
           allowOff:(els.allowDieselOff.value==="true"), rampUp:+els.rampUp.value, rampDn:+els.rampDn.value,
           hyster:+els.dgHyst.value, HperMW:0.5 },
      // BESS
      bess:{ Pmax:+els.PbMax.value, Emax:+els.EbMax.value, E:+els.EbMax.value*(+els.soc0.value/100),
             R:(+els.Rvsg.value)/100, H:+els.Hvsg.value, P:0,
             socTarget:+els.socTarget.value/100, socBand:+els.socBand.value/100,
             femg:+els.femg.value, overMul:+els.overMul.value, overSec:+els.overSec.value, emgLeft:+els.overSec.value },
      // 保护
      D:+els.Dsys.value, alpha:+els.alphaLoad.value/100, rocMax:+els.rocMax.value,
      kof1:+els.kof1.value, kof2:+els.kof2.value, of1f:+els.of1f.value, of1t:+els.of1t.value, of2f:+els.of2f.value, of2t:+els.of2t.value, reclose:+els.reclose.value,
      // KPI
      fuelL:0, E_load:0, pvDir:0, windDir:0, curtWh:0, n1_ok:true,
      // 运行策略
      freezeReduce:false, freezeTimer:0
    };
    buildFleet(+els.dg33n.value, +els.dg12n.value);
    series=[]; els.log.textContent="";
  }

  function buildFleet(n33,n12){
    st.dg.fleet=[];
    for(let i=0;i<6;i++) st.dg.fleet.push(newDG(3.3,"DG3.3", i<n33));
    for(let i=0;i<2;i++) st.dg.fleet.push(newDG(1.25,"DG1.25", i<n12));
    if(!st.dg.allowOff && st.dg.fleet.filter(x=>x.online).length===0){
      st.dg.fleet[0].online=true; st.dg.fleet[0].P=st.dg.fleet[0].cap*0.7;
    }
  }
  function newDG(cap,type,online){ return {cap,type,online,P:online?cap*0.7:0, timer:0, starting:false, stopping:false}; }

  // —— 画像函数 ——
  function loadPower(t,f,f0){
    const base=st.load.base;
    const cyc  = 0.6*st.load.var*Math.sin(2*Math.PI*t/900);   // 15min 周期
    const mech = 0.4*st.load.var*Math.sin(2*Math.PI*t/120);   // 2min 机械振荡
    const droop = (1 - st.alpha*((f - f0)/f0));               // 随频阻尼
    return Math.max(0,(base+cyc+mech)*droop);
  }
  function pvAvail(t,T){
    const Pmax=st.pv.Pmax*st.pv.soil, s=st.pv.shape, x=Math.sin(Math.PI*(t/T));
    const day=Math.max(0,x)**s;
    const n=0.5+0.5*Math.sin(0.03*t)*0.6+0.4*Math.sin(0.011*t+1.7); // 云
    const temp = 1 - 0.06*Math.exp(-Math.pow((t/T-0.5)/0.18,2));     // 温降额（正午热）
    const clip = v=> v>0.97? 0.97+(v-0.97)*0.5 : v;                   // 轻微削顶
    return clip(Pmax*day*Math.max(0,(1-st.pv.cloud)+st.pv.cloud*n)*temp);
  }
  function windSpeed(t){
    const m=st.wind.vmean, v=st.wind.vvar;
    const base = m*(1 + 0.18*Math.sin(0.008*t) + 0.12*Math.sin(0.021*t+1.1));
    const gust = (Math.random()-0.5)*v*1.6; // 阵风
    return Math.max(0, base*(1+gust));
  }
  function windAvail(v){
    const Pmax=st.wind.Pmax;
    if(v<3) return 0;
    if(v<12){ const pu=(v-3)/(12-3); return Pmax*pu*pu; }
    if(v<=25) return Pmax;
    // >25m/s 切出，设复归延时
    if(st.wind.stopReset<=0){ st.wind.stopReset=120; log(`[${st.t.toFixed(0)}s] 风机切出`); }
    return 0;
  }

  // —— 保护：Hz–W 两段 + OF ——
  function limitREByFreq(Pavail, res, dt){
    const f=st.f, f0=st.f0, kof1=st.kof1, kof2=st.kof2;
    if(res.ofTrip>0){ res.ofTrip-=dt; return 0; }                   // 正在重合闸等待
    // OF 计时
    if(f>=st.of2f){ res.ofDelay=(res._band===2?res.ofDelay+dt:dt); res._band=2; if(res.ofDelay>=st.of2t){ res.ofTrip=st.reclose; res.ofDelay=0; res._band=0; log(`[${st.t.toFixed(1)}s] OF2 跳闸`); return 0; } }
    else if(f>=st.of1f){ res.ofDelay=(res._band===1?res.ofDelay+dt:dt); res._band=1; if(res.ofDelay>=st.of1t){ res.ofTrip=st.reclose; res.ofDelay=0; res._band=0; log(`[${st.t.toFixed(1)}s] OF1 跳闸`); return 0; } }
    else { res.ofDelay=Math.max(0,res.ofDelay-2*dt); res._band=0; }

    // 两段 Hz–W（仅当 f>60.2 开始限）
    let scale=1;
    if(f>60.2){
      if(f<60.5) scale = Math.max(0,1 - kof1*(f-60.0));
      else       scale = Math.max(0,1 - kof1*0.5 - kof2*(f-60.5));
    }
    return Pavail*scale;
  }

  // —— 柴油调度（VF）——
  function dieselDispatch(dt, fpu, residual){
    const u=st.dg.fleet;
    // wind 切出复归计时
    if(st.wind.stopReset>0) st.wind.stopReset -= dt;

    // 在线容量/最大机
    let onlineCap=u.reduce((a,x)=>a+(x.online?x.cap:0),0);
    const largest=Math.max(0,...u.filter(x=>x.online).map(x=>x.cap));
    const need=Math.max(0,residual);
    st.n1_ok = ((onlineCap - largest) >= need*0.95);

    const desiredCap = (need>0)? need/0.75 : (st.dg.allowOff?0:3.3); // 预留 25%
    const upH=st.dg.hyster, dnH=st.dg.hyster*1.3; // 启停迟滞
    // 启机：容量不足
    if(onlineCap < desiredCap - upH){ if(!startOne("DG3.3")) startOne("DG1.25"); }
    // 减机：容量富余且未冻结
    else if(onlineCap - desiredCap > dnH && !st.freezeReduce && st.bess.E/st.bess.Emax>0.3){ stopOne(); }

    // 启停过程
    for(const x of u){
      if(x.starting){ x.timer -= dt; if(x.timer<=0){ x.starting=false; x.online=true; x.P=x.cap*0.65; log(`[${st.t.toFixed(0)}s] 并网完成：${x.type}`);} }
      if(x.stopping){ x.P=Math.max(0,x.P - st.dg.rampDn*dt*1.5); x.timer -= dt; if(x.timer<=0){ x.stopping=false; x.online=false; x.P=0; log(`[${st.t.toFixed(0)}s] 解列完成：${x.type}`);} }
    }

    const online = u.filter(x=>x.online);
    const PdgMax=online.reduce((a,x)=>a+x.cap,0);
    // 下垂修正：频高→降出力
    const droopAdj = - fpu / Math.max(0.001, st.dg.Rdg) * PdgMax;
    let Pd_ref = clamp(need + droopAdj, 0, PdgMax);
    // 频率过高时，逼近 sumMin，避免加剧过频
    const sumMin = online.reduce((a,x)=>a + x.cap*st.dg.minPu, 0);
    if(Pd_ref < sumMin) Pd_ref = sumMin;
    if(st.f - st.f0 > 0.2) Pd_ref = Math.min(Pd_ref, sumMin + 0.2*(PdgMax-sumMin));

    // 均分 + 爬坡：下调快、上调慢
    const per = (online.length>0)? Pd_ref/online.length : 0;
    for(const x of online){
      const minP=x.cap*st.dg.minPu;
      const target=clamp(per, minP, x.cap);
      const ramp = (target < x.P) ? st.dg.rampDn : st.dg.rampUp;
      const dP = clamp(target - x.P, -ramp*dt, ramp*dt);
      x.P = clamp(x.P + dP, 0, x.cap);
    }
    return online.reduce((a,x)=>a+x.P,0);

    function startOne(type){
      const cand = u.find(x=>!x.online && !x.starting && x.type===type);
      if(cand){ cand.starting=true; cand.timer=st.dg.delay; log(`[${st.t.toFixed(0)}s] 启动命令：${type}`); return true; }
      return false;
    }
    function stopOne(){
      const cand = u.find(x=>x.online && !x.stopping && !x.starting && x.P < x.cap*0.6);
      if(cand){ cand.stopping=true; cand.timer=st.dg.delay; log(`[${st.t.toFixed(0)}s] 解列命令：${cand.type}`); return true; }
      return false;
    }
  }

  // —— 柴油油耗估算（简表）——
  function fuelLH(u){
    function sfc(pu){ if(pu<=0) return 0;
      if(pu<=0.25) return 350*pu/0.25;
      if(pu<=0.5)  return 300-(300-230)*((pu-0.25)/0.25);
      if(pu<=0.75) return 230-(230-205)*((pu-0.5)/0.25);
      return 205-(205-200)*((pu-0.75)/0.25);
    }
    const rho=0.84; let Lh=0;
    for(const x of u){ if(!x.online||x.P<=0) continue; const pu=clamp(x.P/x.cap,0,1); const kW=x.P*1000; const kgph=(sfc(pu)/1000)*kW; Lh+=kgph/rho; }
    return Lh;
  }

  // —— BESS 三环（Pcorr > Droop > Energy）+ 应急过载 ——
  function bessControl(dt, fpu, Pinj_pre){
    const Pmax=st.bess.Pmax;
    let PmaxEff=Pmax;
    const soc=st.bess.E/st.bess.Emax;
    // 应急过载条件：|Δf|>阈值 & SOC允许 & 时间窗剩余
    if(Math.abs(st.f-st.f0)>st.bess.femg && soc<0.9 && st.bess.emgLeft>0){
      PmaxEff = Pmax*st.bess.overMul;
    }
    const P_droop=clamp(- fpu / Math.max(0.001, st.bess.R) * PmaxEff, -PmaxEff, PmaxEff);
    const P_corr =clamp(- Pinj_pre, -PmaxEff, PmaxEff);
    const err=(st.bess.socTarget - soc);
    const P_energy=clamp(err*Pmax*0.25, -0.6*PmaxEff, 0.6*PmaxEff);
    let Pcmd=0.55*P_corr + 0.35*P_droop + 0.10*P_energy;
    // SOC 软硬边界
    const soft=0.08;
    if(soc<soft) Pcmd=Math.min(Pcmd,0);
    if(soc>1-soft) Pcmd=Math.max(Pcmd,0);
    st.bess.P=clamp(Pcmd,-PmaxEff,PmaxEff);

    // 应急时间窗累计/恢复
    if(PmaxEff>Pmax && Math.abs(st.bess.P)>Pmax){
      st.bess.emgLeft=Math.max(0,st.bess.emgLeft-dt);
      if(st.bess.emgLeft===0) log(`[${st.t.toFixed(0)}s] BESS 应急时间用尽`);
    }else{
      st.bess.emgLeft=Math.min(st.bess.overSec, st.bess.emgLeft+0.3*dt);
    }
  }

  // —— 单步更新 ——
  function step(){
    const dt=+els.dt.value, T=st.T;
    // 画像
    const Ppv_av = pvAvail(st.t,T);
    const vwind = windSpeed(st.t);
    const Pwind_av = (st.wind.stopReset>0)? 0 : windAvail(vwind);
    const Pload = loadPower(st.t, st.f, st.f0);

    // 频率限功/OF
    const Ppv   = limitREByFreq(Ppv_av,   st.pv,   dt);
    const Pwind = limitREByFreq(Pwind_av, st.wind, dt);

    // 柴油前残差
    const residual = Math.max(0, Pload - (Ppv+Pwind));
    const fpu=(st.f - st.f0)/st.f0;

    // 自适应 Sbase
    const onlineCap = st.dg.fleet.reduce((a,x)=>a+(x.online?x.cap:0),0);
    st.Sbase = Math.max(12, Pload, onlineCap);

    // 柴油 + BESS
    const Pdg = dieselDispatch(dt, fpu, residual);
    const Pinj_pre = (Pdg + Ppv + Pwind) - Pload;
    bessControl(dt, fpu, Pinj_pre);

    // 摆动方程 + RoCoF 钳位
    const Hdiesel = onlineCap * st.dg.HperMW;
    const Hsys = Math.max(0.5, Hdiesel + st.bess.H);
    const Pinj = (Pdg + Ppv + Pwind + st.bess.P) - Pload;
    const Pdamp = - st.alpha * fpu * st.Sbase;
    const dpu = (Pinj + Pdamp) / st.Sbase;
    let dfdt = st.f0 * (dpu - st.D*fpu) / (2*Hsys);
    dfdt = clamp(dfdt, -st.rocMax, st.rocMax);
    st.f += dfdt * dt;

    // 能量流 / KPI
    let remain=Pload, pv2L=Math.min(Ppv,remain); remain-=pv2L;
    let wind2L=Math.min(Pwind,remain); remain-=wind2L;
    const Pb=st.bess.P; const chargeCap=Math.max(0,-Pb);
    const surplus = Math.max(0,(Ppv-pv2L)+(Pwind-wind2L));
    const toBess = Math.min(chargeCap, surplus);
    const curt = surplus - toBess;
    st.pv.curtWh   += curt * (Ppv/(Ppv+Pwind+1e-9)) * dt/3600;
    st.wind.curtWh += curt * (Pwind/(Ppv+Pwind+1e-9)) * dt/3600;
    st.curtWh = st.pv.curtWh + st.wind.curtWh;
    st.pvDir   += pv2L*dt/3600;
    st.windDir += wind2L*dt/3600;

    st.bess.E = clamp(st.bess.E - st.bess.P*dt/3600, 0, st.bess.Emax);
    st.E_load += Pload*dt/3600;
    st.fuelL  += fuelLH(st.dg.fleet)*dt/3600;

    // 越限冻结减机
    if(Math.abs(st.f-st.f0)>0.5){ if(!st.freezeReduce){ st.freezeReduce=true; st.freezeTimer=300; log(`[${st.t.toFixed(0)}s] 频率越限，冻结减机 5min`);} }
    if(st.freezeTimer>0){ st.freezeTimer-=dt; if(st.freezeTimer<=0) st.freezeReduce=false; }

    // 记录
    series.push({t:st.t, Ppv, Pwind, Pload, Pdg, Pb:st.bess.P, f:st.f, soc:100*st.bess.E/st.bess.Emax});
    st.t += dt;
  }

  // —— 绘图（两幅图）——
  function drawSeries(ctx,w,h,xs,ys,color, dashed=false, width=2.5){
    ctx.beginPath(); if(dashed) ctx.setLineDash([6,6]); else ctx.setLineDash([]);
    for(let i=0;i<xs.length;i++){ if(i===0) ctx.moveTo(xs[i],ys[i]); else ctx.lineTo(xs[i],ys[i]); }
    ctx.strokeStyle=color; ctx.lineWidth=width; ctx.stroke(); ctx.setLineDash([]);
  }
  function plotPower(){
    const w=els.pPlot.width=Math.floor(els.pPlot.clientWidth*devicePixelRatio);
    const h=els.pPlot.height=Math.floor(els.pPlot.clientHeight*devicePixelRatio);
    const ctx=pctx; ctx.clearRect(0,0,w,h); if(series.length<2) return;
    const T=st.T, xs=series.map(d=>(d.t/T)*(w-60)+40);
    const allP=series.flatMap(d=>[d.Ppv,d.Pwind,d.Pload,d.Pdg,d.Pb]);
    const pmin=Math.min(0,...allP), pmax=Math.max(...allP,1);
    const y=v=>(1-(v-pmin)/(pmax-pmin||1))*(h-36)+18;

    // 网格 & 0轴
    ctx.strokeStyle='#f3f4f6'; ctx.lineWidth=1;
    for(let i=0;i<5;i++){ const yy=(i/4)*(h-36)+18; ctx.beginPath(); ctx.moveTo(40,yy); ctx.lineTo(w-12,yy); ctx.stroke(); }
    const y0=y(0); ctx.beginPath(); ctx.moveTo(40,y0); ctx.lineTo(w-12,y0); ctx.setLineDash([5,5]); ctx.strokeStyle='#9ca3af'; ctx.lineWidth=1.2; ctx.stroke(); ctx.setLineDash([]);

    // 曲线（与 V2.4 一致）
    drawSeries(ctx,w,h,xs,series.map(d=>y(d.Ppv)),   COLORS.pv);
    drawSeries(ctx,w,h,xs,series.map(d=>y(d.Pwind)), COLORS.wind, true);
    drawSeries(ctx,w,h,xs,series.map(d=>y(d.Pload)), COLORS.load);
    drawSeries(ctx,w,h,xs,series.map(d=>y(d.Pdg)),   COLORS.diesel);
    drawSeries(ctx,w,h,xs,series.map(d=>y(d.Pb)),    COLORS.bess);

    // X轴（小时）
    ctx.fillStyle='#374151'; ctx.font=`${11*devicePixelRatio}px sans-serif`;
    for(let hmark=0;hmark<=+els.simHours.value;hmark+=6){
      const x=40+(hmark/+els.simHours.value)*(w-60); ctx.fillText(`${hmark}h`, x-8, h-6);
    }
  }
  function plotFreq(){
    const w=els.fPlot.width=Math.floor(els.fPlot.clientWidth*devicePixelRatio);
    const h=els.fPlot.height=Math.floor(els.fPlot.clientHeight*devicePixelRatio);
    const ctx=fctx; ctx.clearRect(0,0,w,h); if(series.length<2) return;
    const T=st.T, xs=series.map(d=>(d.t/T)*(w-60)+40);
    const fVals=series.map(d=>d.f), sVals=series.map(d=>d.soc);
    const f0=st.f0;
    const fmin=Math.min(...fVals,f0-0.8), fmax=Math.max(...fVals,f0+0.8);
    const yF=v=>(1-(v-fmin)/(fmax-fmin||1))*(h-36)+18;
    const yS=v=>(1-(v-0)/(100-0||1))*(h-36)+18;

    // 网格 + 60Hz 基线
    ctx.strokeStyle='#f3f4f6'; ctx.lineWidth=1;
    for(let i=0;i<5;i++){ const yy=(i/4)*(h-36)+18; ctx.beginPath(); ctx.moveTo(40,yy); ctx.lineTo(w-12,yy); ctx.stroke(); }
    const y60=yF(f0); ctx.beginPath(); ctx.moveTo(40,y60); ctx.lineTo(w-12,y60); ctx.setLineDash([5,5]); ctx.strokeStyle='#9ca3af'; ctx.lineWidth=1.2; ctx.stroke(); ctx.setLineDash([]);

    drawSeries(ctx,w,h,xs,fVals.map(yF),COLORS.freq);
    drawSeries(ctx,w,h,xs,sVals.map(yS),COLORS.soc,true);

    const last=series[series.length-1];
    els.live.textContent=`t=${(last.t/3600).toFixed(2)} h | f=${last.f.toFixed(3)} Hz | PV=${last.Ppv.toFixed(2)} MW | Wind=${last.Pwind.toFixed(2)} MW | Diesel=${last.Pdg.toFixed(2)} MW | BESS=${last.Pb.toFixed(2)} MW | SOC=${last.soc.toFixed(1)}% | Load=${last.Pload.toFixed(2)} MW`;

    ctx.fillStyle='#374151'; ctx.font=`${11*devicePixelRatio}px sans-serif`;
    for(let hmark=0;hmark<=+els.simHours.value;hmark+=6){
      const x=40+(hmark/+els.simHours.value)*(w-60); ctx.fillText(`${hmark}h`, x-8, h-6);
    }

    // KPI 最近窗口（1h）
    const tmax=last.t, tmin=Math.max(0,tmax-3600);
    const seg=series.filter(d=>d.t>=tmin);
    if(seg.length>2){
      const fmaxSeg=Math.max(...seg.map(d=>d.f));
      const fminSeg=Math.min(...seg.map(d=>d.f));
      const pbMax=Math.max(...seg.map(d=>Math.abs(d.Pb)));
      els.kpiWin.textContent = `f∈[${fminSeg.toFixed(2)}, ${fmaxSeg.toFixed(2)}] Hz · |BESS|_max=${pbMax.toFixed(2)} MW`;
    }
  }

  function refreshKPI(){
    els.kpiFuel.textContent=fmt(st.fuelL,"L");
    const E_RE=st.pvDir+st.windDir;
    els.kpiRE.textContent=fmt(st.E_load>0?100*E_RE/st.E_load:0,"%");
    els.kpiCurt.textContent=fmt(st.curtWh,"MWh");
    els.kpiN1.textContent=st.n1_ok?"OK":"Not Met";
  }

  function loop(){ if(!running) return; step(); plotPower(); plotFreq(); refreshKPI(); requestAnimationFrame(loop); }

  // —— 交互 ——
  els.startBtn.onclick=()=>{ if(!running){ if(series.length===0) initState(); running=true; requestAnimationFrame(loop);} };
  els.pauseBtn.onclick=()=>{ running=false; };
  els.resetBtn.onclick=()=>{ running=false; initState(); plotPower(); plotFreq(); refreshKPI(); };

  // 初始渲染
  initState(); plotPower(); plotFreq(); refreshKPI();

})();
</script>
</body>
</html>