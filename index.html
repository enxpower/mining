<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>离网矿区光风储柴仿真 V2.5.1 — 35kV母线 | VF Diesel · VSG BESS · PV/Wind</title>
<style>
  :root { --fg:#111; --muted:#666; --line:#e5e7eb; --box:#d1d5db; }
  * { box-sizing: border-box; }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Noto Sans", sans-serif; color: var(--fg); margin: 14px; background:#fff; }
  h1 { font-size: 18px; margin: 0 0 8px; }
  .sub { color: var(--muted); font-size: 12px; }
  .row { display:flex; flex-wrap:wrap; gap:12px; margin: 10px 0; }
  .card { border: 1px solid var(--box); border-radius: 10px; padding: 12px; flex: 1 1 320px; background:#fff; }
  label { display:block; font-size:12px; margin: 6px 0 3px; }
  input[type=number], select { width:100%; padding: 7px 9px; border:1px solid #cbd5e1; border-radius:8px; }
  .btn { padding:8px 12px; border:1px solid #111; border-radius:8px; background:#fff; cursor:pointer; }
  .btn:active { transform: translateY(1px); }
  .btn.secondary { border-color:#666; color:#333; }
  .btn.group { margin-right:6px; }
  .pill { display:inline-block; border:1px solid #cbd5e1; border-radius:999px; padding:2px 8px; margin-right:6px; font-size:12px; }
  .kv { font-family: ui-monospace, Menlo, Consolas, monospace; }
  canvas { width:100%; height:260px; background:#fff; border:1px solid #eee; border-radius:10px; }
  .kpi { display:flex; gap:14px; flex-wrap:wrap; }
  .kpi .box { border:1px solid var(--box); border-radius:10px; padding:8px 10px; min-width: 150px; }
  .kpi .box b { display:block; font-size:12px; color:#374151; }
  .kpi .box span { display:block; font-size:18px; margin-top:2px; }
  .flag { display:inline-block; padding:2px 6px; border-radius:6px; font-size:12px; border:1px solid var(--box); }
  .ok { color: #0072B2; border-color: #0072B2; }
  .warn { color: #E69F00; border-color: #E69F00; }
  .bad  { color: #D55E00; border-color: #D55E00; }
  #log  { font-family: ui-monospace,Menlo,Consolas,monospace; font-size:12px; max-height:200px; overflow:auto; background:#fafafa; border:1px solid #eee; border-radius:8px; padding:8px; }
  #err  { display:none; margin:8px 0; padding:8px 10px; border-radius:8px; border:1px solid #ef4444; color:#991b1b; background:#fff1f2; font-size:12px; }
</style>
</head>
<body>
<h1>Off-Grid Mining Microgrid — <span class="kv">35 kV</span> <span class="pill">Diesel=VF</span><span class="pill">BESS=VSG</span><span class="pill">PV/Wind=GFL</span></h1>
<div class="sub">V2.5.1：修复“开始后无曲线”问题（自动启动、空画布保护、错误提示）；其余模型同 V2.5。</div>
<div id="err"></div>

<div class="row">
  <div class="card">
    <b>时间轴与全局</b>
    <label>总时长（小时）</label><input id="simHours" type="number" value="24" step="1">
    <label>步长 dt（秒）</label><input id="dt" type="number" value="0.5" step="0.1">
    <label>名义频率 f0（Hz）</label><input id="f0" type="number" value="60" step="1">
    <div class="row" style="gap:8px; margin-top:6px">
      <div style="flex:1"><label>系统阻尼 D（pu）</label><input id="Dsys" type="number" value="2.5" step="0.1"></div>
      <div style="flex:1"><label>负荷阻尼 α（%/Hz）</label><input id="alphaLoad" type="number" value="2.0" step="0.1"></div>
      <div style="flex:1"><label>RoCoF 限值（Hz/s）</label><input id="rocMax" type="number" value="0.9" step="0.1"></div>
    </div>
    <div style="margin-top:8px">
      <button class="btn group" id="startBtn">▶ 开始</button>
      <button class="btn group secondary" id="pauseBtn">⏸ 暂停</button>
      <button class="btn group secondary" id="resetBtn">↺ 重置</button>
    </div>
  </div>

  <div class="card">
    <b>负载 & 可再生（24h 曲线）</b>
    <label>连续负载基线（MW）</label><input id="Pload" type="number" value="12" step="0.5">
    <label>负载波动幅度（MW）</label><input id="loadVar" type="number" value="0.8" step="0.2">
    <hr>
    <label>PV 装机上限（MW）</label><input id="PpvMax" type="number" value="30" step="1">
    <label>PV 日形（1–3）</label><input id="pvShape" type="number" value="1.5" min="1" max="3" step="0.1">
    <label>云影强度（0–1）</label><input id="pvCloud" type="number" value="0.35" min="0" max="1" step="0.05">
    <label>污染/积尘系数（0.7–1）</label><input id="pvSoil" type="number" value="0.9" min="0.7" max="1" step="0.01">
    <hr>
    <label>风电装机（MW）</label><input id="PwindMax" type="number" value="6" step="1">
    <label>平均风速（m/s）</label><input id="windMean" type="number" value="8" step="0.5">
    <label>风速波动强度（0–1）</label><input id="windVar" type="number" value="0.4" min="0" max="1" step="0.05">
  </div>

  <div class="card">
    <b>Hz–W 限功与 OF 保护</b>
    <label>限功斜率 k<sub>of</sub></label><input id="kof" type="number" value="2.0" step="0.1">
    <label>OF1 阈值（Hz）/时限（s）</label>
    <div class="row" style="gap:8px"><input id="of1f" type="number" value="60.5" step="0.1"><input id="of1t" type="number" value="10" step="1"></div>
    <label>OF2 阈值（Hz）/时限（s）</label>
    <div class="row" style="gap:8px"><input id="of2f" type="number" value="61.0" step="0.1"><input id="of2t" type="number" value="0.2" step="0.1"></div>
    <label>跳闸后重连延时（s）</label><input id="reclose" type="number" value="30" step="1">
  </div>

  <div class="card">
    <b>柴油机群（VF + 调速/汽机）</b>
    <label>3.3 MW 初始在网台数（0–6）</label><input id="dg33n" type="number" value="3" min="0" max="6" step="1">
    <label>1.25 MW 初始在网台数（0–2）</label><input id="dg12n" type="number" value="0" min="0" max="2" step="1">
    <label>有功下垂 R<sub>P</sub>（%）</label><input id="Rdg" type="number" value="4" step="0.5">
    <label>单台最低负载（pu）</label><input id="dgMinPu" type="number" value="0.35" step="0.05">
    <label>上调爬坡（MW/s）</label><input id="rampUp" type="number" value="0.2" step="0.05">
    <label>下调爬坡（MW/s）</label><input id="rampDn" type="number" value="1.0" step="0.1">
    <label>启停延时（s）</label><input id="dgDelay" type="number" value="600" step="30">
    <div class="row" style="gap:8px">
      <div style="flex:1"><label>调速器常数 T<sub>g</sub>（s）</label><input id="Tg" type="number" value="2.0" step="0.1"></div>
      <div style="flex:1"><label>汽机常数 T<sub>m</sub>（s）</label><input id="Tm" type="number" value="6.0" step="0.1"></div>
    </div>
    <label>允许 Diesel-Off</label>
    <select id="allowDieselOff"><option value="false" selected>否（至少1台）</option><option value="true">是</option></select>
  </div>

  <div class="card">
    <b>储能（VSG）</b>
    <label>P<sub>max</sub>（MW）</label><input id="PbMax" type="number" value="8" step="0.5">
    <label>E<sub>max</sub>（MWh）</label><input id="EbMax" type="number" value="20" step="1">
    <label>初始 SOC（%）</label><input id="soc0" type="number" value="60" min="5" max="95" step="1">
    <label>VSG 虚拟惯量 H（s）</label><input id="Hvsg" type="number" value="6.0" step="0.1">
    <label>有功下垂 R<sub>P</sub>（%）</label><input id="Rvsg" type="number" value="3" step="0.5">
    <label>SOC 目标/窗口（%，如55±10）</label>
    <div class="row" style="gap:8px"><input id="socTarget" type="number" value="55" step="1"><input id="socBand" type="number" value="10" step="1"></div>
    <label>应急吸收：频差阈值（Hz）/ 过载倍数 / 最长时间（s）</label>
    <div class="row" style="gap:8px"><input id="femg" type="number" value="0.2" step="0.05"><input id="overMul" type="number" value="1.4" step="0.1"><input id="overSec" type="number" value="8" step="1"></div>
  </div>
</div>

<div class="row">
  <div class="card" style="flex: 2 1 560px">
    <b>功率（MW）· 24小时</b>
    <canvas id="pPlot"></canvas>
  </div>
  <div class="card" style="flex: 1 1 340px">
    <b>频率（Hz）/ SOC（%）· 24小时</b>
    <canvas id="fPlot"></canvas>
    <div id="live" class="kv" style="margin-top:6px"></div>
  </div>
</div>

<div class="row">
  <div class="card" style="flex:1 1 420px">
    <b>扰动触发（秒级动态分析）</b>
    <div class="row" style="gap:8px">
      <button class="btn" id="stepLoadUp">+1 MW 负载（60s）</button>
      <button class="btn" id="stepLoadDn">−1 MW 负载（60s）</button>
      <button class="btn" id="pvDrop">PV −5 MW（30s）</button>
      <button class="btn" id="tripDiesel">跳闸一台柴油</button>
    </div>
    <label style="margin-top:8px">秒级窗口（s）</label><input id="dynWin" type="number" value="120" step="10">
    <div class="sub">触发后在右侧“秒级响应”图查看 f/dfdt 与 Diesel/BESS 的瞬态反应。</div>
  </div>
  <div class="card" style="flex:2 1 520px">
    <b>秒级响应（最近窗口）</b>
    <canvas id="dynPlot"></canvas>
  </div>
</div>

<div class="card">
  <b>运行指标（累计）</b>
  <div class="kpi" id="kpiRow">
    <div class="box"><b>燃油消耗</b><span id="kpiFuel">0 L</span></div>
    <div class="box"><b>可再生占比</b><span id="kpiRE">0%</span></div>
    <div class="box"><b>弃电（PV+风）</b><span id="kpiCurt">0 MWh</span></div>
    <div class="box"><b>N−1 校核</b><span id="kpiN1"><span class="flag ok">OK</span></span></div>
  </div>
</div>

<div class="card">
  <b>事件日志</b>
  <div id="log"></div>
</div>

<script>
(function(){
  const ERR = document.getElementById('err');
  function showErr(e){ ERR.style.display='block'; ERR.textContent = '⚠️ 运行异常：' + e; console.error(e); }

  try{
    const DPR = (window.devicePixelRatio || 1);
    const COLORS = { pv:'#E69F00', wind:'#D55E00', load:'#000000', diesel:'#0072B2', bess:'#009E73', freq:'#6A3D9A', soc:'#009E73' };
    const clamp=(x,min,max)=>Math.max(min,Math.min(max,x));
    const fmt=(v,u)=>v.toLocaleString(undefined,{maximumFractionDigits:(Math.abs(v)<10?2:1)})+(u?(" "+u):"");
    const el=id=>document.getElementById(id);
    const els={
      simHours:el('simHours'), dt:el('dt'), f0:el('f0'), Dsys:el('Dsys'), alphaLoad:el('alphaLoad'), rocMax:el('rocMax'),
      Pload:el('Pload'), loadVar:el('loadVar'),
      PpvMax:el('PpvMax'), pvShape:el('pvShape'), pvCloud:el('pvCloud'), pvSoil:el('pvSoil'),
      PwindMax:el('PwindMax'), windMean:el('windMean'), windVar:el('windVar'),
      kof:el('kof'), of1f:el('of1f'), of1t:el('of1t'), of2f:el('of2f'), of2t:el('of2t'), reclose:el('reclose'),
      dg33n:el('dg33n'), dg12n:el('dg12n'), Rdg:el('Rdg'), dgMinPu:el('dgMinPu'), rampUp:el('rampUp'), rampDn:el('rampDn'), dgDelay:el('dgDelay'), allowDieselOff:el('allowDieselOff'), Tg:el('Tg'), Tm:el('Tm'),
      PbMax:el('PbMax'), EbMax:el('EbMax'), soc0:el('soc0'), Hvsg:el('Hvsg'), Rvsg:el('Rvsg'), socTarget:el('socTarget'), socBand:el('socBand'),
      femg:el('femg'), overMul:el('overMul'), overSec:el('overSec'),
      startBtn:el('startBtn'), pauseBtn:el('pauseBtn'), resetBtn:el('resetBtn'),
      stepLoadUp:el('stepLoadUp'), stepLoadDn:el('stepLoadDn'), pvDrop:el('pvDrop'), tripDiesel:el('tripDiesel'), dynWin:el('dynWin'),
      pPlot:el('pPlot'), fPlot:el('fPlot'), dynPlot:el('dynPlot'), live:el('live'),
      kpiFuel:el('kpiFuel'), kpiRE:el('kpiRE'), kpiCurt:el('kpiCurt'), kpiN1:el('kpiN1'),
      log:el('log')
    };
    const pctx=els.pPlot.getContext('2d'); const fctx=els.fPlot.getContext('2d'); const dctx=els.dynPlot.getContext('2d');
    function log(msg){ els.log.innerText += `[${st.t.toFixed(1)}s] ${msg}\n`; els.log.scrollTop=els.log.scrollHeight; }

    let running=false, series=[], st={};
    const events={ loadOffset:0, loadTimer:0, pvDropMW:0, pvTimer:0, tripPending:false };

    function initState(){
      const f0=+els.f0.value;
      st={
        t:0, f0, f:f0, T:+els.simHours.value*3600,
        Sbase: Math.max(12, +els.Pload.value),
        dg:{ fleet:[], Rdg:(+els.Rdg.value)/100, minPu:+els.dgMinPu.value, delay:+els.dgDelay.value,
             allowOff:(els.allowDieselOff.value==="true"), rampUp:+els.rampUp.value, rampDn:+els.rampDn.value,
             HperMW:0.5, max33:6, max12:2, Tg:+els.Tg.value, Tm:+els.Tm.value },
        bess:{ Pmax:+els.PbMax.value, Emax:+els.EbMax.value, E:+els.EbMax.value*(+els.soc0.value/100),
               H:+els.Hvsg.value, R:(+els.Rvsg.value)/100, P:0,
               socTarget:+els.socTarget.value/100, socBand:+els.socBand.value/100,
               overMul:+els.overMul.value, femg:+els.femg.value, overSec:+els.overSec.value, emgLeft:+els.overSec.value },
        pv:{ Pmax:+els.PpvMax.value, shape:+els.pvShape.value, cloud:+els.pvCloud.value, soil:+els.pvSoil.value, E_direct:0, curtWh:0, ofTrip:0, ofDelay:0 },
        wind:{ Pmax:+els.PwindMax.value, vmean:+els.windMean.value, vvar:+els.windVar.value, E_direct:0, curtWh:0, ofTrip:0, ofDelay:0 },
        load:{ base:+els.Pload.value, var:+els.loadVar.value },
        D:+els.Dsys.value, alpha:+els.alphaLoad.value/100, rocMax:+els.rocMax.value,
        fuelL:0, E_load:0, curtWh:0, n1_ok:true,
        freezeReduce:false, freezeTimer:0
      };
      buildFleet(+els.dg33n.value, +els.dg12n.value);
      series=[]; els.log.innerText="";
      events.loadOffset=0; events.loadTimer=0; events.pvDropMW=0; events.pvTimer=0; events.tripPending=false;
    }
    function buildFleet(n33, n12){
      st.dg.fleet=[];
      for(let i=0;i<st.dg.max33;i++) st.dg.fleet.push(newDG(3.3,"DG3.3", i<n33));
      for(let i=0;i<st.dg.max12;i++) st.dg.fleet.push(newDG(1.25,"DG1.25", i<n12));
      if(!st.dg.allowOff && st.dg.fleet.filter(u=>u.online).length===0){
        st.dg.fleet[0].online=true; st.dg.fleet[0].P=st.dg.fleet[0].cap*0.7; st.dg.fleet[0].gov=st.dg.fleet[0].P; st.dg.fleet[0].mech=st.dg.fleet[0].P;
      }
    }
    function newDG(cap,type,online){ return {cap,type,online,P:online?cap*0.7:0, timer:0, starting:false, stopping:false, gov:0, mech:0}; }

    function pvAvail(time,T){
      const Pmax=st.pv.Pmax*st.pv.soil, s=st.pv.shape, c=st.pv.cloud;
      const x=Math.sin(Math.PI*(time/T)); const day=Math.max(0,x)**s;
      const n=0.5+0.5*Math.sin(0.03*time)*0.6+0.4*Math.sin(0.011*time+1.7);
      return Pmax*day*Math.max(0,Math.min(1,(1-c)+c*n));
    }
    function windSpeed(time){
      const mean=st.wind.vmean, vari=st.wind.vvar;
      return Math.max(0, mean*(1 + 0.2*Math.sin(0.005*time) + 0.15*Math.sin(0.017*time+1.1))*(1 + (vari-0.5)*0.6*Math.sin(0.09*time+0.8)));
    }
    function windAvail(v){
      const Pmax=st.wind.Pmax;
      if(v<3) return 0; if(v<12){ const pu=(v-3)/(12-3); return Pmax*pu*pu; }
      if(v<=25) return Pmax; return 0;
    }
    function loadPower(time){
      const base = st.load.base + st.load.var*Math.sin(2*Math.PI*time/900);
      const off = events.loadOffset;
      return Math.max(0, base + off);
    }

    function limitREByFreq(Pavail, res, dt){
      const kof=+els.kof.value, of1f=+els.of1f.value, of1t=+els.of1t.value, of2f=+els.of2f.value, of2t=+els.of2t.value, recl=+els.reclose.value;
      const f=st.f, f0=st.f0;
      if(res.ofTrip>0){ res.ofTrip -= dt; return 0; }
      if(f>=of2f){ res.ofDelay += dt; if(res.ofDelay>=of2t){ res.ofTrip=recl; res.ofDelay=0; log("OF2 跳闸，切除可再生"); return 0; } }
      else if(f>=of1f){ res.ofDelay += dt; if(res.ofDelay>=of1t){ res.ofTrip=recl; res.ofDelay=0; log("OF1 跳闸，切除可再生"); return 0; } }
      else{ res.ofDelay = Math.max(0, res.ofDelay - 2*dt); }
      const df = Math.max(0, f - f0);
      const scale = Math.max(0, 1 - kof*df);
      return Pavail * scale;
    }

    function dieselDispatch(dt, fpu, residual){
      const u=st.dg.fleet;
      let onlineCap=u.reduce((a,x)=>a+(x.online?x.cap:0),0);
      const largest=Math.max(0, ...u.filter(x=>x.online).map(x=>x.cap));
      const need=Math.max(0,residual);
      st.n1_ok = ((onlineCap - largest) >= need*0.95);

      function startOne(type){
        const cand = u.find(x=>!x.online && !x.starting && x.type===type);
        if(cand){ cand.starting=true; cand.timer=st.dg.delay; log(`启动命令：${type}`); return true; }
        return false;
      }
      function stopOne(){
        const cand = u.find(x=>x.online && !x.stopping && !x.starting && x.P < x.cap*0.6);
        if(cand){ cand.stopping=true; cand.timer=st.dg.delay; log(`解列命令：${cand.type}`); return true; }
        return false;
      }

      const desiredCap = (need>0)? need/0.75 : (st.dg.allowOff?0:3.3);
      if(onlineCap < desiredCap - 0.3){ if(!startOne("DG3.3")) startOne("DG1.25"); }
      else if(onlineCap - desiredCap > 2.0 && !st.freezeReduce && st.bess.E/st.bess.Emax>0.3){ stopOne(); }

      for(const x of u){
        if(x.starting){ x.timer -= dt; if(x.timer<=0){ x.starting=false; x.online=true; x.P=x.cap*0.65; x.gov=x.P; x.mech=x.P; log(`并网完成：${x.type}`);} }
        if(x.stopping){ x.P=Math.max(0, x.P - st.dg.rampDn*dt*1.5); x.timer -= dt; if(x.timer<=0){ x.stopping=false; x.online=false; x.P=0; log(`解列完成：${x.type}`);} }
      }

      const online = u.filter(x=>x.online);
      const PdgMax=online.reduce((a,x)=>a+x.cap,0);
      const droopAdj = - fpu / Math.max(0.001, st.dg.Rdg) * PdgMax;
      let Pd_ref = clamp(need + droopAdj, 0, PdgMax);
      const sumMin = online.reduce((a,x)=>a + x.cap*st.dg.minPu, 0);
      if(Pd_ref < sumMin) Pd_ref = sumMin;
      if(st.f - st.f0 > 0.2) Pd_ref = Math.min(Pd_ref, sumMin + 0.2*(PdgMax-sumMin));

      const per = (online.length>0)? Pd_ref/online.length : 0;
      for(const x of online){
        const minP=x.cap*st.dg.minPu;
        const target=clamp(per, minP, x.cap);
        x.gov  += (target - x.gov) * dt/Math.max(0.05, st.dg.Tg);
        x.mech += (x.gov  - x.mech) * dt/Math.max(0.1,  st.dg.Tm);
        const ramp = (x.mech < x.P) ? st.dg.rampDn : st.dg.rampUp;
        const dP=clamp(x.mech - x.P, -ramp*dt, ramp*dt);
        x.P = clamp(x.P + dP, 0, x.cap);
      }
      return online.reduce((a,x)=>a+x.P,0);
    }

    function fuelLH(u){
      function sfc(pu){ if(pu<=0) return 0; if(pu<=0.25) return 350*pu/0.25;
        if(pu<=0.5) return 300-(300-230)*((pu-0.25)/0.25);
        if(pu<=0.75) return 230-(230-205)*((pu-0.5)/0.25);
        return 205-(205-200)*((pu-0.75)/0.25); }
      const rho=0.84; let Lh=0;
      for(const x of u){ if(!x.online||x.P<=0) continue; const pu=clamp(x.P/x.cap,0,1); const kW=x.P*1000; const kgph=(sfc(pu)/1000)*kW; Lh+=kgph/rho; }
      return Lh;
    }

    function bessControl(dt, fpu, Pinj_pre){
      const Pmax=st.bess.Pmax;
      let PmaxEff=Pmax;
      const soc=st.bess.E/st.bess.Emax;
      if(Math.abs(st.f-st.f0)>st.bess.femg && soc<0.9 && st.bess.emgLeft>0){ PmaxEff = Pmax*st.bess.overMul; }
      const P_droop=clamp(- fpu / Math.max(0.001, st.bess.R) * PmaxEff, -PmaxEff, PmaxEff);
      const P_corr =clamp(- Pinj_pre, -PmaxEff, PmaxEff);
      const err=(st.bess.socTarget - soc);
      const P_energy=clamp(err*Pmax*0.25, -0.6*PmaxEff, 0.6*PmaxEff);
      let Pcmd=0.55*P_corr + 0.35*P_droop + 0.10*P_energy;
      const soft=0.08; if(soc<soft) Pcmd=Math.min(Pcmd,0); if(soc>1-soft) Pcmd=Math.max(Pcmd,0);
      st.bess.P=clamp(Pcmd,-PmaxEff,PmaxEff);
      if(PmaxEff>Pmax && Math.abs(st.bess.P)>Pmax){
        st.bess.emgLeft = Math.max(0, st.bess.emgLeft - dt);
        if(st.bess.emgLeft===0) log("BESS 应急过载时间耗尽");
      } else { st.bess.emgLeft = Math.min(st.bess.overSec, st.bess.emgLeft + 0.3*dt); }
    }

    function step(){
      const dt=+els.dt.value, T=st.T;
      if(!(dt>0)){ throw new Error('步长 dt 必须 > 0'); }

      if(events.loadTimer>0){ events.loadTimer-=dt; if(events.loadTimer<=0){ events.loadOffset=0; log("负载阶跃结束"); } }
      if(events.pvTimer>0){ events.pvTimer-=dt; if(events.pvTimer<=0){ events.pvDropMW=0; log("PV 突降结束"); } }
      if(events.tripPending){
        const on = st.dg.fleet.filter(x=>x.online && !x.stopping && !x.starting);
        if(on.length>0){ on.sort((a,b)=>b.P-a.P); const g=on[0]; g.online=false; g.P=0; g.gov=0; g.mech=0; log(`跳闸：${g.type}`); }
        else { log("跳闸失败：无在线机组"); }
        events.tripPending=false;
      }

      let Ppv_av = pvAvail(st.t,T);
      const Pwind_av = windAvail( windSpeed(st.t) );
      const Pload = loadPower(st.t);

      Ppv_av = Math.max(0, Ppv_av - (events.pvDropMW||0));

      const Ppv   = limitREByFreq(Ppv_av,   st.pv,   dt);
      const Pwind = limitREByFreq(Pwind_av, st.wind, dt);

      const residual = Math.max(0, Pload - (Ppv+Pwind));
      const fpu=(st.f - st.f0)/st.f0;

      const onlineCap = st.dg.fleet.reduce((a,x)=>a+(x.online?x.cap:0),0);
      st.Sbase = Math.max(12, Pload, onlineCap);

      const Pdg = dieselDispatch(dt, fpu, residual);
      const Pinj_pre = (Pdg + Ppv + Pwind) - Pload;
      bessControl(dt, fpu, Pinj_pre);

      const Hdiesel = onlineCap * st.dg.HperMW;
      const Hsys = Math.max(0.5, Hdiesel + st.bess.H);
      const Pinj = (Pdg + Ppv + Pwind + st.bess.P) - Pload;
      const Pdamp = - st.alpha * fpu * st.Sbase;
      const dpu = (Pinj + Pdamp) / st.Sbase;
      let dfdt = st.f0 * (dpu - st.D*fpu) / (2*Hsys);
      dfdt = clamp(dfdt, -st.rocMax, st.rocMax);
      st.f += dfdt * dt;

      let remain=Pload, pv2L=Math.min(Ppv,remain); remain-=pv2L;
      let wind2L=Math.min(Pwind,remain); remain-=wind2L;
      const Pb=st.bess.P; const chargeCap=Math.max(0,-Pb);
      const surplus = Math.max(0,(Ppv-pv2L)+(Pwind-wind2L));
      const toBess = Math.min(chargeCap, surplus);
      const curt = surplus - toBess;
      st.pv.curtWh   += curt * (Ppv/(Ppv+Pwind+1e-9)) * dt/3600;
      st.wind.curtWh += curt * (Pwind/(Ppv+Pwind+1e-9)) * dt/3600;
      st.curtWh = st.pv.curtWh + st.wind.curtWh;
      st.pv.E_direct   += pv2L*dt/3600; st.wind.E_direct += wind2L*dt/3600;

      st.bess.E = clamp(st.bess.E - st.bess.P*dt/3600, 0, st.bess.Emax);
      st.E_load += Pload*dt/3600;
      st.fuelL  += fuelLH(st.dg.fleet)*dt/3600;

      if(Math.abs(st.f-st.f0)>0.5){ st.freezeReduce=true; st.freezeTimer=300; log("频率越限，冻结减机5min"); }
      if(st.freezeTimer>0){ st.freezeTimer-=dt; if(st.freezeTimer<=0) st.freezeReduce=false; }

      series.push({t:st.t, Ppv, Pwind, Pload, Pdg, Pb:st.bess.P, f:st.f, soc:100*st.bess.E/st.bess.Emax, dfdt});
      st.t += dt;
    }

    function drawSeries(ctx,w,h,xs,ys,color, dashed=false, width=2.5){
      ctx.beginPath();
      if(dashed){ ctx.setLineDash([6,6]); } else { ctx.setLineDash([]); }
      for(let i=0;i<xs.length;i++){ if(i===0) ctx.moveTo(xs[i],ys[i]); else ctx.lineTo(xs[i],ys[i]); }
      ctx.strokeStyle=color; ctx.lineWidth=width; ctx.stroke(); ctx.setLineDash([]);
    }

    function ensureCanvasSize(c){
      const w = Math.max(1, Math.floor((c.clientWidth||c.parentElement.clientWidth||600)*DPR));
      const h = Math.max(1, Math.floor((c.clientHeight||260)*DPR));
      c.width=w; c.height=h; return {w,h};
    }

    function plotPower(){
      const {w,h}=ensureCanvasSize(els.pPlot);
      const ctx=pctx; ctx.clearRect(0,0,w,h);
      if(series.length<2) return;
      const T=st.T;
      const xs=series.map(d=>(d.t/T)*(w-60)+40);
      const allP=series.flatMap(d=>[d.Ppv,d.Pwind,d.Pload,d.Pdg,d.Pb]);
      const pmin=Math.min(0,...allP), pmax=Math.max(...allP,1);
      const y=v=>(1-(v-pmin)/(pmax-pmin||1))*(h-36)+18;
      ctx.strokeStyle='#f3f4f6'; ctx.lineWidth=1;
      for(let i=0;i<5;i++){ const yy=(i/4)*(h-36)+18; ctx.beginPath(); ctx.moveTo(40,yy); ctx.lineTo(w-12,yy); ctx.stroke(); }
      const y0=y(0); ctx.beginPath(); ctx.moveTo(40,y0); ctx.lineTo(w-12,y0); ctx.setLineDash([5,5]); ctx.strokeStyle='#9ca3af'; ctx.lineWidth=1.2; ctx.stroke(); ctx.setLineDash([]);
      drawSeries(ctx,w,h,xs,series.map(d=>y(d.Ppv)),'#E69F00');
      drawSeries(ctx,w,h,xs,series.map(d=>y(d.Pwind)),'#D55E00', true);
      drawSeries(ctx,w,h,xs,series.map(d=>y(d.Pload)),'#000000');
      drawSeries(ctx,w,h,xs,series.map(d=>y(d.Pdg)),'#0072B2');
      drawSeries(ctx,w,h,xs,series.map(d=>y(d.Pb)),'#009E73');
      ctx.fillStyle='#374151'; ctx.font=`${11*DPR}px sans-serif`;
      for(let hmark=0; hmark<=+els.simHours.value; hmark+=6){ const x=40+(hmark/+els.simHours.value)*(w-60); ctx.fillText(`${hmark}h`, x-8, h-6); }
    }

    function plotFreq(){
      const {w,h}=ensureCanvasSize(els.fPlot);
      const ctx=fctx; ctx.clearRect(0,0,w,h);
      if(series.length<2) return;
      const T=st.T;
      const xs=series.map(d=>(d.t/T)*(w-60)+40);
      const fVals=series.map(d=>d.f), sVals=series.map(d=>d.soc);
      const f0=st.f0;
      const fmin=Math.min(...fVals,f0-0.8), fmax=Math.max(...fVals,f0+0.8);
      const yF=v=>(1-(v-fmin)/(fmax-fmin||1))*(h-36)+18;
      const yS=v=>(1-(v-0)/(100-0||1))*(h-36)+18;
      ctx.strokeStyle='#f3f4f6'; ctx.lineWidth=1;
      for(let i=0;i<5;i++){ const yy=(i/4)*(h-36)+18; ctx.beginPath(); ctx.moveTo(40,yy); ctx.lineTo(w-12,yy); ctx.stroke(); }
      const y60=yF(f0); ctx.beginPath(); ctx.moveTo(40,y60); ctx.lineTo(w-12,y60); ctx.setLineDash([5,5]); ctx.strokeStyle='#9ca3af'; ctx.lineWidth=1.2; ctx.stroke(); ctx.setLineDash([]);
      drawSeries(ctx,w,h,xs,fVals.map(yF),'#6A3D9A');
      drawSeries(ctx,w,h,xs,sVals.map(yS),'#009E73',true);
      const last=series[series.length-1];
      els.live.textContent = `t=${(last.t/3600).toFixed(2)} h | f=${last.f.toFixed(3)} Hz | PV=${last.Ppv.toFixed(2)} MW | Wind=${last.Pwind.toFixed(2)} MW | Diesel=${last.Pdg.toFixed(2)} MW | BESS=${last.Pb.toFixed(2)} MW | SOC=${last.soc.toFixed(1)}% | Load=${last.Pload.toFixed(2)} MW`;
      ctx.fillStyle='#374151'; ctx.font=`${11*DPR}px sans-serif`;
      for(let hmark=0; hmark<=+els.simHours.value; hmark+=6){ const x=40+(hmark/+els.simHours.value)*(w-60); ctx.fillText(`${hmark}h`, x-8, h-6); }
    }

    function plotDyn(){
      const {w,h}=ensureCanvasSize(els.dynPlot);
      const ctx=dctx; ctx.clearRect(0,0,w,h);
      if(series.length<2) return;
      const win=+els.dynWin.value;
      const tmax=series[series.length-1].t, tmin=Math.max(0, tmax-win);
      const seg=series.filter(d=>d.t>=tmin);
      if(seg.length<2) return;
      const xs=seg.map(d=>((d.t - tmin)/win)*(w-60)+40);
      const fVals=seg.map(d=>d.f), PdgVals=seg.map(d=>d.Pdg), PbVals=seg.map(d=>d.Pb);
      const f0=st.f0;
      const fmin=Math.min(...fVals,f0-0.6), fmax=Math.max(...fVals,f0+0.6);
      const yL=v=>(1-(v-fmin)/(fmax-fmin||1))*(h-36)+18;
      const pmin=Math.min(...PdgVals, ...PbVals, 0), pmax=Math.max(...PdgVals, ...PbVals, 1);
      const yR=v=>(1-(v-pmin)/(pmax-pmin||1))*(h-36)+18;
      ctx.strokeStyle='#f3f4f6'; ctx.lineWidth=1;
      for(let i=0;i<5;i++){ const yy=(i/4)*(h-36)+18; ctx.beginPath(); ctx.moveTo(40,yy); ctx.lineTo(w-12,yy); ctx.stroke(); }
      const y60=yL(f0); ctx.beginPath(); ctx.moveTo(40,y60); ctx.lineTo(w-12,y60); ctx.setLineDash([5,5]); ctx.strokeStyle='#cbd5e1'; ctx.lineWidth=1.2; ctx.stroke(); ctx.setLineDash([]);
      const rocof=[]; for(let i=1;i<seg.length;i++){ rocof.push((seg[i].f - seg[i-1].f)/((seg[i].t - seg[i-1].t)||1)); }
      const xs2=xs.slice(1);
      drawSeries(ctx,w,h,xs2,rocof.map(v=>yL(f0+v)),'#6A3D9A',true,2);
      drawSeries(ctx,w,h,xs,fVals.map(yL),'#6A3D9A',false,2.5);
      ctx.beginPath(); ctx.setLineDash([]); ctx.strokeStyle='#0072B2'; ctx.lineWidth=2.5;
      for(let i=0;i<xs.length;i++){ const y=yR(PdgVals[i]); if(i===0) ctx.moveTo(xs[i],y); else ctx.lineTo(xs[i],y); } ctx.stroke();
      ctx.beginPath(); ctx.setLineDash([6,6]); ctx.strokeStyle='#009E73'; ctx.lineWidth=2.5;
      for(let i=0;i<xs.length;i++){ const y=yR(PbVals[i]); if(i===0) ctx.moveTo(xs[i],y); else ctx.lineTo(xs[i],y); } ctx.stroke(); ctx.setLineDash([]);
      ctx.fillStyle='#374151'; ctx.font=`${11*DPR}px sans-serif`;
      ctx.fillText(`t = ${win}s 窗口`, 44, 16); ctx.fillText(`Hz`, 8, 26); ctx.fillText(`MW`, w-36, 26);
      for(let sm=0; sm<=win; sm+=Math.max(10, Math.round(win/6))){ const x=40+(sm/win)*(w-60); ctx.fillText(`${sm}s`, x-10, h-6); }
    }

    function refreshKPI(){
      els.kpiFuel.textContent = fmt(st.fuelL,"L");
      const E_RE = st.pv.E_direct + st.wind.E_direct;
      const re = (st.E_load>0)? 100*E_RE/st.E_load : 0;
      els.kpiRE.textContent = fmt(Math.min(re,100),"%");
      els.kpiCurt.textContent = fmt(st.curtWh,"MWh");
      els.kpiN1.innerHTML = st.n1_ok ? '<span class="flag ok">OK</span>' : '<span class="flag bad">Not Met</span>';
    }

    function loop(){ if(!running) return; step(); plotPower(); plotFreq(); plotDyn(); refreshKPI(); (window.requestAnimationFrame||function(fn){return setTimeout(fn,16)})(loop); }

    els.startBtn.onclick=()=>{ if(!running){ if(series.length===0) initState(); running=true; (window.requestAnimationFrame||function(fn){return setTimeout(fn,16)})(loop);} };
    els.pauseBtn.onclick=()=>{ running=false; };
    els.resetBtn.onclick=()=>{ running=false; initState(); plotPower(); plotFreq(); plotDyn(); refreshKPI(); };

    els.stepLoadUp.onclick=()=>{ events.loadOffset += 1; events.loadTimer=Math.max(events.loadTimer,60); log("扰动：负载 +1 MW，维持 60 s"); };
    els.stepLoadDn.onclick=()=>{ events.loadOffset -= 1; events.loadTimer=Math.max(events.loadTimer,60); log("扰动：负载 −1 MW，维持 60 s"); };
    els.pvDrop.onclick=()=>{ events.pvDropMW = 5; events.pvTimer = Math.max(events.pvTimer,30); log("扰动：PV 突降 −5 MW，维持 30 s"); };
    els.tripDiesel.onclick=()=>{ events.tripPending=true; log("扰动：将跳闸一台在线柴油机"); };

    // 初始渲染 & 自动启动（避免“开始后无反应”的体验）
    initState(); plotPower(); plotFreq(); plotDyn(); refreshKPI();
    els.startBtn.click();

    // 窗口大小变化时重绘（避免 clientWidth=0 的时机问题）
    window.addEventListener('resize', ()=>{ plotPower(); plotFreq(); plotDyn(); });

  }catch(e){ showErr(e); }
})();
</script>
</body>
</html>